// Generated from diagram.schema.json (sha1:0b04bf3463933dc7f2b89ba3bf4378156e20b93e)
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type NextOperation =
  | string
  | {
      builtin: BuiltinTarget;
      [k: string]: unknown;
    }
  | NamespacedOperation;
export type BuiltinTarget = "terminate" | "dispose" | "cancel";
export type DiagramOperation =
  | {
      builder: string;
      config?: {
        [k: string]: unknown;
      };
      next: NextOperation;
      type: "node";
      [k: string]: unknown;
    }
  | (
      | {
          builder: string;
        }
      | {
          template: string;
        }
    )
  | {
      next: NextOperation[];
      type: "fork_clone";
      [k: string]: unknown;
    }
  | {
      next: NextOperation[];
      type: "unzip";
      [k: string]: unknown;
    }
  | {
      err: NextOperation;
      ok: NextOperation;
      type: "fork_result";
      [k: string]: unknown;
    }
  | {
      keyed?: {
        [k: string]: NextOperation;
      };
      remaining?: NextOperation | null;
      sequential?: NextOperation[];
      type: "split";
      [k: string]: unknown;
    }
  | {
      /**
       * Map of buffer keys and buffers.
       */
      buffers: BufferSelection;
      next: NextOperation;
      type: "join";
      [k: string]: unknown;
    }
  | {
      /**
       * Map of buffer keys and buffers.
       */
      buffers: BufferSelection;
      next: NextOperation;
      type: "serialized_join";
      [k: string]: unknown;
    }
  | {
      cel: string;
      next: NextOperation;
      /**
       * Specify what happens if an error occurs during the transformation. If you specify a target for on_error, then an error message will be sent to that target. You can set this to `{ "builtin": "dispose" }` to simply ignore errors.
       *
       * If left unspecified, a failure will be treated like an implicit operation failure and behave according to `on_implicit_error`.
       */
      on_error?: NextOperation | null;
      type: "transform";
      [k: string]: unknown;
    }
  | {
      /**
       * If true, messages will be serialized before sending into the buffer.
       */
      serialize?: boolean | null;
      settings?: BufferSettings;
      type: "buffer";
      [k: string]: unknown;
    }
  | {
      /**
       * Map of buffer keys and buffers.
       */
      buffers: BufferSelection;
      next: NextOperation;
      type: "buffer_access";
      [k: string]: unknown;
    }
  | {
      /**
       * Map of buffer keys and buffers.
       */
      buffers: BufferSelection;
      next: NextOperation;
      /**
       * The id of an operation that this operation is for. The id must be a `node` operation. Optional if `next` is a node operation.
       */
      target_node?: NextOperation | null;
      type: "listen";
      [k: string]: unknown;
    };
export type BufferSelection =
  | NextOperation
  | {
      [k: string]: NextOperation;
    }
  | NextOperation[];
/**
 * Describe how data within a buffer gets retained. Most mechanisms that pull data from a buffer will remove the oldest item in the buffer, so this policy is for dealing with situations where items are being stored faster than they are being pulled.
 *
 * The default value is KeepLast(1).
 */
export type RetentionPolicy =
  | {
      keep_last: number;
    }
  | {
      keep_first: number;
    }
  | "keep_all";
/**
 * This defines how sections remap their inner operations (inputs and buffers) to expose them to operations that are siblings to the section.
 */
export type InputRemapping =
  | string[]
  | {
      [k: string]: NextOperation;
    };

export interface Diagram {
  /**
   * To simplify diagram definitions, the diagram workflow builder will sometimes insert implicit operations into the workflow, such as implicit serializing and deserializing. These implicit operations may be fallible.
   *
   * This field indicates how a failed implicit operation should be handled. If left unspecified, an implicit error will cause the entire workflow to be cancelled.
   */
  on_implicit_error?: NextOperation | null;
  /**
   * Operations that define the workflow
   */
  ops: {
    [k: string]: DiagramOperation;
  };
  /**
   * Indicates where the workflow should start running.
   */
  start: NextOperation;
  templates?: {
    [k: string]: SectionTemplate;
  };
  /**
   * Version of the diagram, should always be `0.1.0`.
   */
  version: string;
  [k: string]: unknown;
}
/**
 * Refer to an operation inside of a namespace, e.g. { "<namespace>": "<operation>"
 */
export interface NamespacedOperation {
  [k: string]: string;
}
/**
 * Settings to describe the behavior of a buffer.
 */
export interface BufferSettings {
  retention: RetentionPolicy;
  [k: string]: unknown;
}
export interface SectionTemplate {
  /**
   * These are the buffers that the section is exposing for you to read, write, join, or listen to.
   */
  buffers?: InputRemapping;
  /**
   * These are the inputs that the section is exposing for its sibling operations to send outputs into.
   */
  inputs?: InputRemapping;
  /**
   * Operations that define the behavior of the section.
   */
  ops: {
    [k: string]: DiagramOperation;
  };
  /**
   * These are the outputs that the section is exposing so you can connect them into siblings of the section.
   */
  outputs?: string[];
  [k: string]: unknown;
}
