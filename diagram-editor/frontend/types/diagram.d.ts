// Generated from diagram.schema.json (sha1:30d3fb25901a2a71ed3b3e58b09b31a935cc0aaa)
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type NextOperation =
  | string
  | {
      builtin: BuiltinTarget;
      [k: string]: unknown;
    }
  | NamespacedOperation;
export type BuiltinTarget = 'terminate' | 'dispose' | 'cancel';
export type DiagramOperation =
  | ({
      type: 'node';
      [k: string]: unknown;
    } & NodeSchema)
  | ({
      type: 'section';
      [k: string]: unknown;
    } & SectionSchema)
  | ({
      type: 'scope';
      [k: string]: unknown;
    } & ScopeSchema)
  | ({
      type: 'stream_out';
      [k: string]: unknown;
    } & StreamOutSchema)
  | ({
      type: 'fork_clone';
      [k: string]: unknown;
    } & ForkCloneSchema)
  | ({
      type: 'unzip';
      [k: string]: unknown;
    } & UnzipSchema)
  | ({
      type: 'fork_result';
      [k: string]: unknown;
    } & ForkResultSchema)
  | ({
      type: 'split';
      [k: string]: unknown;
    } & SplitSchema)
  | ({
      type: 'join';
      [k: string]: unknown;
    } & JoinSchema)
  | ({
      type: 'serialized_join';
      [k: string]: unknown;
    } & SerializedJoinSchema)
  | ({
      type: 'transform';
      [k: string]: unknown;
    } & TransformSchema)
  | ({
      type: 'buffer';
      [k: string]: unknown;
    } & BufferSchema)
  | ({
      type: 'buffer_access';
      [k: string]: unknown;
    } & BufferAccessSchema)
  | ({
      type: 'listen';
      [k: string]: unknown;
    } & ListenSchema);
export type SectionSchema = {
  config?: {
    [k: string]: unknown;
  };
  connect?: {
    [k: string]: NextOperation;
  };
  [k: string]: unknown;
} & SectionSchema1;
export type SectionSchema1 =
  | {
      builder: string;
      [k: string]: unknown;
    }
  | {
      template: string;
      [k: string]: unknown;
    };
export type BufferSelection =
  | {
      [k: string]: NextOperation;
    }
  | NextOperation[];
/**
 * Describe how data within a buffer gets retained. Most mechanisms that pull
 *  data from a buffer will remove the oldest item in the buffer, so this policy
 *  is for dealing with situations where items are being stored faster than they
 *  are being pulled.
 *
 *  The default value is KeepLast(1).
 */
export type RetentionPolicy =
  | {
      keep_last: number;
    }
  | {
      keep_first: number;
    }
  | 'keep_all';
/**
 * This defines how sections remap their inner operations (inputs and buffers)
 *  to expose them to operations that are siblings to the section.
 */
export type InputRemapping =
  | string[]
  | {
      [k: string]: NextOperation;
    };

export interface Diagram {
  /**
   * To simplify diagram definitions, the diagram workflow builder will
   *  sometimes insert implicit operations into the workflow, such as implicit
   *  serializing and deserializing. These implicit operations may be fallible.
   *
   *  This field indicates how a failed implicit operation should be handled.
   *  If left unspecified, an implicit error will cause the entire workflow to
   *  be cancelled.
   */
  on_implicit_error?: NextOperation | null;
  /**
   * Operations that define the workflow
   */
  ops: {
    [k: string]: DiagramOperation;
  };
  /**
   * Indicates where the workflow should start running.
   */
  start:
    | string
    | {
        builtin: BuiltinTarget;
        [k: string]: unknown;
      }
    | NamespacedOperation;
  templates?: {
    [k: string]: SectionTemplate;
  };
  /**
   * Version of the diagram, should always be `0.1.0`.
   */
  version: string;
  [k: string]: unknown;
}
/**
 * Refer to an operation inside of a namespace, e.g. { "<namespace>": "<operation>"
 */
export interface NamespacedOperation {
  [k: string]: string;
}
export interface NodeSchema {
  builder: string;
  config?: unknown;
  next: NextOperation;
  stream_out?: {
    [k: string]: NextOperation;
  };
  [k: string]: unknown;
}
/**
 * The schema to define a scope within a diagram.
 */
export interface ScopeSchema {
  next: NextOperation;
  /**
   * To simplify diagram definitions, the diagram workflow builder will
   *  sometimes insert implicit operations into the workflow, such as implicit
   *  serializing and deserializing. These implicit operations may be fallible.
   *
   *  This field indicates how a failed implicit operation should be handled.
   *  If left unspecified, an implicit error will cause the entire workflow to
   *  be cancelled.
   */
  on_implicit_error?: NextOperation | null;
  /**
   * Operations that exist inside this scope.
   */
  ops: {
    [k: string]: DiagramOperation;
  };
  settings?: {
    [k: string]: unknown;
  } & ScopeSettings;
  start: NextOperation;
  /**
   * Where to connect streams that are coming out of this scope.
   */
  stream_out?: {
    [k: string]: NextOperation;
  };
  [k: string]: unknown;
}
/**
 * Settings which determine how the top-level scope of the workflow behaves.
 */
export interface ScopeSettings {
  /**
   * Should we prevent the scope from being interrupted (e.g. cancelled)?
   *  False by default, meaning by default scopes can be cancelled or
   *  interrupted.
   */
  uninterruptible: boolean;
  [k: string]: unknown;
}
export interface StreamOutSchema {
  /**
   * The name of the stream exiting the workflow or scope.
   */
  name: string;
  [k: string]: unknown;
}
export interface ForkCloneSchema {
  next: NextOperation[];
  [k: string]: unknown;
}
export interface UnzipSchema {
  next: NextOperation[];
  [k: string]: unknown;
}
export interface ForkResultSchema {
  err: NextOperation;
  ok: NextOperation;
  [k: string]: unknown;
}
export interface SplitSchema {
  keyed?: {
    [k: string]: NextOperation;
  };
  remaining?: NextOperation | null;
  sequential?: NextOperation[];
  [k: string]: unknown;
}
export interface JoinSchema {
  buffers: BufferSelection;
  next: NextOperation;
  [k: string]: unknown;
}
export interface SerializedJoinSchema {
  buffers: BufferSelection;
  next: NextOperation;
  [k: string]: unknown;
}
export interface TransformSchema {
  cel: string;
  next: NextOperation;
  /**
   * Specify what happens if an error occurs during the transformation. If
   *  you specify a target for on_error, then an error message will be sent to
   *  that target. You can set this to `{ "builtin": "dispose" }` to simply
   *  ignore errors.
   *
   *  If left unspecified, a failure will be treated like an implicit operation
   *  failure and behave according to `on_implicit_error`.
   */
  on_error?: NextOperation | null;
  [k: string]: unknown;
}
export interface BufferSchema {
  /**
   * If true, messages will be serialized before sending into the buffer.
   */
  serialize?: boolean | null;
  settings?: {
    [k: string]: unknown;
  } & BufferSettings;
  [k: string]: unknown;
}
/**
 * Settings to describe the behavior of a buffer.
 */
export interface BufferSettings {
  retention: RetentionPolicy;
  [k: string]: unknown;
}
export interface BufferAccessSchema {
  buffers: BufferSelection;
  next: NextOperation;
  [k: string]: unknown;
}
export interface ListenSchema {
  buffers: BufferSelection;
  next: NextOperation;
  /**
   * The id of an operation that this operation is for. The id must be a `node` operation. Optional if `next` is a node operation.
   */
  target_node?: NextOperation | null;
  [k: string]: unknown;
}
export interface SectionTemplate {
  buffers?: {
    [k: string]: unknown;
  } & InputRemapping;
  inputs?: {
    [k: string]: unknown;
  } & InputRemapping;
  /**
   * Operations that define the behavior of the section.
   */
  ops: {
    [k: string]: DiagramOperation;
  };
  /**
   * These are the outputs that the section is exposing so you can connect
   *  them into siblings of the section.
   */
  outputs?: string[];
  [k: string]: unknown;
}
