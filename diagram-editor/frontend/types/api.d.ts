/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "BufferSelection".
 */
export type BufferSelection =
  | {
      [k: string]: NextOperation;
    }
  | NextOperation[];
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "NextOperation".
 */
export type NextOperation =
  | string
  | {
      builtin: BuiltinTarget;
      [k: string]: unknown;
    }
  | NamespacedOperation;
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "BuiltinTarget".
 */
export type BuiltinTarget = 'terminate' | 'dispose' | 'cancel';
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "TraceToggle".
 */
export type TraceToggle = 'off' | 'on' | 'messages';
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "RetentionPolicy".
 */
export type RetentionPolicy =
  | {
      keep_last: number;
    }
  | {
      keep_first: number;
    }
  | 'keep_all';
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "DebugSessionMessage".
 */
export type DebugSessionMessage =
  | ({
      operationStarted: string;
      [k: string]: unknown;
    } & {
      type: 'feedback';
      [k: string]: unknown;
    })
  | ((
      | {
          ok: unknown;
          [k: string]: unknown;
        }
      | {
          err: string;
          [k: string]: unknown;
        }
    ) & {
      type: 'finish';
      [k: string]: unknown;
    });
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "DiagramOperation".
 */
export type DiagramOperation =
  | (NodeSchema & {
      type: 'node';
      [k: string]: unknown;
    })
  | (SectionSchema & {
      type: 'section';
      [k: string]: unknown;
    })
  | (ScopeSchema & {
      type: 'scope';
      [k: string]: unknown;
    })
  | (StreamOutSchema & {
      type: 'stream_out';
      [k: string]: unknown;
    })
  | (ForkCloneSchema & {
      type: 'fork_clone';
      [k: string]: unknown;
    })
  | (UnzipSchema & {
      type: 'unzip';
      [k: string]: unknown;
    })
  | (ForkResultSchema & {
      type: 'fork_result';
      [k: string]: unknown;
    })
  | (SplitSchema & {
      type: 'split';
      [k: string]: unknown;
    })
  | (JoinSchema & {
      type: 'join';
      [k: string]: unknown;
    })
  | (SerializedJoinSchema & {
      type: 'serialized_join';
      [k: string]: unknown;
    })
  | (TransformSchema & {
      type: 'transform';
      [k: string]: unknown;
    })
  | (BufferSchema & {
      type: 'buffer';
      [k: string]: unknown;
    })
  | (BufferAccessSchema & {
      type: 'buffer_access';
      [k: string]: unknown;
    })
  | (ListenSchema & {
      type: 'listen';
      [k: string]: unknown;
    });
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SectionSchema".
 */
export type SectionSchema = (
  | {
      builder: string;
      [k: string]: unknown;
    }
  | {
      template: string;
      [k: string]: unknown;
    }
) & {
  config?: {
    [k: string]: unknown;
  };
  connect?: {
    [k: string]: NextOperation;
  };
  /**
   * Override for text that should be displayed for an operation within an
   *  editor.
   */
  display_text?: string | null;
  trace?: TraceToggle | null;
  [k: string]: unknown;
};
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "InputRemapping".
 */
export type InputRemapping =
  | string[]
  | {
      [k: string]: NextOperation;
    };
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "Schema".
 */
export type Schema =
  | {
      [k: string]: unknown;
    }
  | boolean;

export interface DiagramEditorApi {
  [k: string]: unknown;
}
/**
 * Zip a message together with access to one or more buffers.
 *
 *  The receiving node must have an input type of `(Message, Keys)`
 *  where `Keys` implements the [`Accessor`][1] trait.
 *
 *  [1]: crate::Accessor
 *
 *  # Examples
 *  ```
 *  # bevy_impulse::Diagram::from_json_str(r#"
 *  {
 *      "version": "0.1.0",
 *      "start": "fork_clone",
 *      "ops": {
 *          "fork_clone": {
 *              "type": "fork_clone",
 *              "next": ["num_output", "string_output"]
 *          },
 *          "num_output": {
 *              "type": "node",
 *              "builder": "num_output",
 *              "next": "buffer_access"
 *          },
 *          "string_output": {
 *              "type": "node",
 *              "builder": "string_output",
 *              "next": "string_buffer"
 *          },
 *          "string_buffer": {
 *              "type": "buffer"
 *          },
 *          "buffer_access": {
 *              "type": "buffer_access",
 *              "buffers": ["string_buffer"],
 *              "target_node": "with_buffer_access",
 *              "next": "with_buffer_access"
 *          },
 *          "with_buffer_access": {
 *              "type": "node",
 *              "builder": "with_buffer_access",
 *              "next": { "builtin": "terminate" }
 *          }
 *      }
 *  }
 *  # "#)?;
 *  # Ok::<_, serde_json::Error>(())
 *  ```
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "BufferAccessSchema".
 */
export interface BufferAccessSchema {
  buffers: BufferSelection;
  /**
   * Override for text that should be displayed for an operation within an
   *  editor.
   */
  display_text?: string | null;
  next: NextOperation;
  trace?: TraceToggle | null;
  [k: string]: unknown;
}
/**
 * Refer to an operation inside of a namespace, e.g. { "<namespace>": "<operation>"
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "NamespacedOperation".
 */
export interface NamespacedOperation {
  [k: string]: string;
}
/**
 * Create a [`Buffer`][1] which can be used to store and pull data within
 *  a scope.
 *
 *  By default the [`BufferSettings`][2] will keep the single last message
 *  pushed to the buffer. You can change that with the optional `settings`
 *  property.
 *
 *  Use the `"serialize": true` option to serialize the messages into
 *  [`JsonMessage`] before they are inserted into the buffer. This
 *  allows any serializable message type to be pushed into the buffer. If
 *  left unspecified, the buffer will store the specific data type that gets
 *  pushed into it. If the buffer inputs are not being serialized, then all
 *  incoming messages being pushed into the buffer must have the same type.
 *
 *  [1]: crate::Buffer
 *  [2]: crate::BufferSettings
 *
 *  # Examples
 *  ```
 *  # bevy_impulse::Diagram::from_json_str(r#"
 *  {
 *      "version": "0.1.0",
 *      "start": "fork_clone",
 *      "ops": {
 *          "fork_clone": {
 *              "type": "fork_clone",
 *              "next": ["num_output", "string_output", "all_num_buffer", "serialized_num_buffer"]
 *          },
 *          "num_output": {
 *              "type": "node",
 *              "builder": "num_output",
 *              "next": "buffer_access"
 *          },
 *          "string_output": {
 *              "type": "node",
 *              "builder": "string_output",
 *              "next": "string_buffer"
 *          },
 *          "string_buffer": {
 *              "type": "buffer",
 *              "settings": {
 *                  "retention": { "keep_last": 10 }
 *              }
 *          },
 *          "all_num_buffer": {
 *              "type": "buffer",
 *              "settings": {
 *                  "retention": "keep_all"
 *              }
 *          },
 *          "serialized_num_buffer": {
 *              "type": "buffer",
 *              "serialize": true
 *          },
 *          "buffer_access": {
 *              "type": "buffer_access",
 *              "buffers": ["string_buffer"],
 *              "target_node": "with_buffer_access",
 *              "next": "with_buffer_access"
 *          },
 *          "with_buffer_access": {
 *              "type": "node",
 *              "builder": "with_buffer_access",
 *              "next": { "builtin": "terminate" }
 *          }
 *      }
 *  }
 *  # "#)?;
 *  # Ok::<_, serde_json::Error>(())
 *  ```
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "BufferSchema".
 */
export interface BufferSchema {
  /**
   * Override for text that should be displayed for an operation within an
   *  editor.
   */
  display_text?: string | null;
  /**
   * If true, messages will be serialized before sending into the buffer.
   */
  serialize?: boolean | null;
  settings?: BufferSettings;
  trace?: TraceToggle | null;
  [k: string]: unknown;
}
/**
 * Settings to describe the behavior of a buffer.
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "BufferSettings".
 */
export interface BufferSettings {
  retention: RetentionPolicy;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "Diagram".
 */
export interface Diagram {
  default_trace?: TraceToggle;
  on_implicit_error?: NextOperation | null;
  /**
   * Operations that define the workflow
   */
  ops: {
    [k: string]: DiagramOperation;
  };
  start: NextOperation;
  templates?: {
    [k: string]: SectionTemplate;
  };
  /**
   * Version of the diagram, should always be `0.1.0`.
   */
  version: string;
  [k: string]: unknown;
}
/**
 * Create an operation that that takes an input message and produces an
 *  output message.
 *
 *  The behavior is determined by the choice of node `builder` and
 *  optioanlly the `config` that you provide. Each type of node builder has
 *  its own schema for the config.
 *
 *  The output message will be sent to the operation specified by `next`.
 *
 *  TODO(@mxgrey): [Support stream outputs](https://github.com/open-rmf/bevy_impulse/issues/43)
 *
 *  # Examples
 *  ```
 *  # bevy_impulse::Diagram::from_json_str(r#"
 *  {
 *      "version": "0.1.0",
 *      "start": "cutting_board",
 *      "ops": {
 *          "cutting_board": {
 *              "type": "node",
 *              "builder": "chop",
 *              "config": "diced",
 *              "next": "bowl"
 *          },
 *          "bowl": {
 *              "type": "node",
 *              "builder": "stir",
 *              "next": "oven"
 *          },
 *          "oven": {
 *              "type": "node",
 *              "builder": "bake",
 *              "config": {
 *                  "temperature": 200,
 *                  "duration": 120
 *              },
 *              "next": { "builtin": "terminate" }
 *          }
 *      }
 *  }
 *  # "#)?;
 *  # Ok::<_, serde_json::Error>(())
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "NodeSchema".
 */
export interface NodeSchema {
  builder: string;
  config?: unknown;
  /**
   * Override for text that should be displayed for an operation within an
   *  editor.
   */
  display_text?: string | null;
  next: NextOperation;
  stream_out?: {
    [k: string]: NextOperation;
  };
  trace?: TraceToggle | null;
  [k: string]: unknown;
}
/**
 * Create a scope which will function like its own encapsulated workflow
 *  within the paren workflow. Each message that enters a scope will trigger
 *  a new independent session for that scope to begin running with the incoming
 *  message itself being the input message of the scope. When multiple sessions
 *  for the same scope are running, they cannot see or interfere with each other.
 *
 *  Once a session terminates, the scope will send the terminating message as
 *  its output. Scopes can use the `stream_out` operation to stream messages out
 *  to the parent workflow while running.
 *
 *  Scopes have two common uses:
 *  * isolate - Prevent simultaneous runs of the same workflow components
 *    (especially buffers) from interfering with each other.
 *  * race - Run multiple branches simultaneously inside the scope and race
 *    them against each ohter. The first branch that reaches the scope's
 *    terminate operation "wins" the race, and only its output will continue
 *    on in the parent workflow. All other branches will be disposed.
 *
 *  # Examples
 *  ```
 *  # bevy_impulse::Diagram::from_json_str(r#"
 *  {
 *      "version": "0.1.0",
 *      "start": "approach_door",
 *      "ops": {
 *          "approach_door": {
 *              "type": "scope",
 *              "start": "begin",
 *              "ops": {
 *                  "begin": {
 *                      "type": "fork_clone",
 *                      "next": [
 *                          "move_to_door",
 *                          "detect_door_proximity"
 *                      ]
 *                  },
 *                  "move_to_door": {
 *                      "type": "node",
 *                      "builder": "move",
 *                      "config": {
 *                          "place": "L1_north_lobby_outside"
 *                      },
 *                      "next": { "builtin" : "terminate" }
 *                  },
 *                  "detect_proximity": {
 *                      "type": "node",
 *                      "builder": "detect_proximity",
 *                      "config": {
 *                          "type": "door",
 *                          "name": "L1_north_lobby"
 *                      },
 *                      "next": { "builtin" : "terminate" }
 *                  }
 *              },
 *              "next": { "builtin" : "try_open_door" }
 *          }
 *      }
 *  }
 *  # "#)?;
 *  # Ok::<_, serde_json::Error>(())
 *  ```
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "ScopeSchema".
 */
export interface ScopeSchema {
  next: NextOperation;
  on_implicit_error?: NextOperation | null;
  /**
   * Operations that exist inside this scope.
   */
  ops: {
    [k: string]: DiagramOperation;
  };
  settings?: ScopeSettings;
  start: NextOperation;
  /**
   * Where to connect streams that are coming out of this scope.
   */
  stream_out?: {
    [k: string]: NextOperation;
  };
  [k: string]: unknown;
}
/**
 * Settings which determine how the top-level scope of the workflow behaves.
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "ScopeSettings".
 */
export interface ScopeSettings {
  /**
   * Should we prevent the scope from being interrupted (e.g. cancelled)?
   *  False by default, meaning by default scopes can be cancelled or
   *  interrupted.
   */
  uninterruptible: boolean;
  [k: string]: unknown;
}
/**
 * Declare a stream output for the current scope. Outputs that you connect
 *  to this operation will be streamed out of the scope that this operation
 *  is declared in.
 *
 *  For the root-level scope, make sure you use a stream pack that is
 *  compatible with all stream out operations that you declare, otherwise
 *  you may get a connection error at runtime.
 *
 *  # Examples
 *  ```
 *  # bevy_impulse::Diagram::from_json_str(r#"
 *  {
 *      "version": "0.1.0",
 *      "start": "plan",
 *      "ops": {
 *          "progress_stream": {
 *              "type": "stream_out",
 *              "name": "progress"
 *          },
 *          "plan": {
 *              "type": "node",
 *              "builder": "planner",
 *              "next": "drive",
 *              "stream_out" : {
 *                  "progress": "progress_stream"
 *              }
 *          },
 *          "drive": {
 *              "type": "node",
 *              "builder": "navigation",
 *              "next": { "builtin": "terminate" },
 *              "stream_out": {
 *                  "progress": "progress_stream"
 *              }
 *          }
 *      }
 *  }
 *  # "#)?;
 *  # Ok::<_, serde_json::Error>(())
 *  ```
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "StreamOutSchema".
 */
export interface StreamOutSchema {
  /**
   * The name of the stream exiting the workflow or scope.
   */
  name: string;
  [k: string]: unknown;
}
/**
 * If the request is cloneable, clone it into multiple responses that can
 *  each be sent to a different operation. The `next` property is an array.
 *
 *  This creates multiple simultaneous branches of execution within the
 *  workflow. Usually when you have multiple branches you will either
 *  * race - connect all branches to `terminate` and the first branch to
 *    finish "wins" the race and gets to the be output
 *  * join - connect each branch into a buffer and then use the `join`
 *    operation to reunite them
 *  * collect - TODO(@mxgrey): [add the collect operation](https://github.com/open-rmf/bevy_impulse/issues/59)
 *
 *  # Examples
 *  ```
 *  # bevy_impulse::Diagram::from_json_str(r#"
 *  {
 *      "version": "0.1.0",
 *      "start": "begin_race",
 *      "ops": {
 *          "begin_race": {
 *              "type": "fork_clone",
 *              "next": [
 *                  "ferrari",
 *                  "mustang"
 *              ]
 *          },
 *          "ferrari": {
 *              "type": "node",
 *              "builder": "drive",
 *              "config": "ferrari",
 *              "next": { "builtin": "terminate" }
 *          },
 *          "mustang": {
 *              "type": "node",
 *              "builder": "drive",
 *              "config": "mustang",
 *              "next": { "builtin": "terminate" }
 *          }
 *      }
 *  }
 *  # "#)?;
 *  # Ok::<_, serde_json::Error>(())
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "ForkCloneSchema".
 */
export interface ForkCloneSchema {
  /**
   * Override for text that should be displayed for an operation within an
   *  editor.
   */
  display_text?: string | null;
  next: NextOperation[];
  trace?: TraceToggle | null;
  [k: string]: unknown;
}
/**
 * If the input message is a tuple of (T1, T2, T3, ...), unzip it into
 *  multiple output messages of T1, T2, T3, ...
 *
 *  Each output message may have a different type and can be sent to a
 *  different operation. This creates multiple simultaneous branches of
 *  execution within the workflow. See [`DiagramOperation::ForkClone`] for
 *  more information on parallel branches.
 *
 *  # Examples
 *  ```
 *  # bevy_impulse::Diagram::from_json_str(r#"
 *  {
 *      "version": "0.1.0",
 *      "start": "name_phone_address",
 *      "ops": {
 *          "name_phone_address": {
 *              "type": "unzip",
 *              "next": [
 *                  "process_name",
 *                  "process_phone_number",
 *                  "process_address"
 *              ]
 *          },
 *          "process_name": {
 *              "type": "node",
 *              "builder": "process_name",
 *              "next": "name_processed"
 *          },
 *          "process_phone_number": {
 *              "type": "node",
 *              "builder": "process_phone_number",
 *              "next": "phone_number_processed"
 *          },
 *          "process_address": {
 *              "type": "node",
 *              "builder": "process_address",
 *              "next": "address_processed"
 *          },
 *          "name_processed": { "type": "buffer" },
 *          "phone_number_processed": { "type": "buffer" },
 *          "address_processed": { "type": "buffer" },
 *          "finished": {
 *              "type": "join",
 *              "buffers": [
 *                  "name_processed",
 *                  "phone_number_processed",
 *                  "address_processed"
 *              ],
 *              "next": { "builtin": "terminate" }
 *          }
 *      }
 *  }
 *  # "#)?;
 *  # Ok::<_, serde_json::Error>(())
 *  ```
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "UnzipSchema".
 */
export interface UnzipSchema {
  /**
   * Override for text that should be displayed for an operation within an
   *  editor.
   */
  display_text?: string | null;
  next: NextOperation[];
  trace?: TraceToggle | null;
  [k: string]: unknown;
}
/**
 * If the request is a [`Result<T, E>`], send the output message down an
 *  `ok` branch or down an `err` branch depending on whether the result has
 *  an [`Ok`] or [`Err`] value. The `ok` branch will receive a `T` while the
 *  `err` branch will receive an `E`.
 *
 *  Only one branch will be activated by each input message that enters the
 *  operation.
 *
 *  # Examples
 *  ```
 *  # bevy_impulse::Diagram::from_json_str(r#"
 *  {
 *      "version": "0.1.0",
 *      "start": "fork_result",
 *      "ops": {
 *          "fork_result": {
 *              "type": "fork_result",
 *              "ok": { "builtin": "terminate" },
 *              "err": { "builtin": "dispose" }
 *          }
 *      }
 *  }
 *  # "#)?;
 *  # Ok::<_, serde_json::Error>(())
 *  ```
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "ForkResultSchema".
 */
export interface ForkResultSchema {
  /**
   * Override for text that should be displayed for an operation within an
   *  editor.
   */
  display_text?: string | null;
  err: NextOperation;
  ok: NextOperation;
  trace?: TraceToggle | null;
  [k: string]: unknown;
}
/**
 * If the input message is a list-like or map-like object, split it into
 *  multiple output messages.
 *
 *  Note that the type of output message from the split depends on how the
 *  input message implements the [`Splittable`][1] trait. In many cases this
 *  will be a tuple of `(key, value)`.
 *
 *  There are three ways to specify where the split output messages should
 *  go, and all can be used at the same time:
 *  * `sequential` - For array-like collections, send the "first" element of
 *    the collection to the first operation listed in the `sequential` array.
 *    The "second" element of the collection goes to the second operation
 *    listed in the `sequential` array. And so on for all elements in the
 *    collection. If one of the elements in the collection is mentioned in
 *    the `keyed` set, then the sequence will pass over it as if the element
 *    does not exist at all.
 *  * `keyed` - For map-like collections, send the split element associated
 *    with the specified key to its associated output.
 *  * `remaining` - Any elements that are were not captured by `sequential`
 *    or by `keyed` will be sent to this.
 *
 *  [1]: crate::Splittable
 *
 *  # Examples
 *
 *  Suppose I am an animal rescuer sorting through a new collection of
 *  animals that need recuing. My home has space for three exotic animals
 *  plus any number of dogs and cats.
 *
 *  I have a custom `SpeciesCollection` data structure that implements
 *  [`Splittable`][1] by allowing you to key on the type of animal.
 *
 *  In the workflow below, we send all cats and dogs to `home`, and we also
 *  send the first three non-dog and non-cat species to `home`. All
 *  remaining animals go to the zoo.
 *
 *  ```
 *  # bevy_impulse::Diagram::from_json_str(r#"
 *  {
 *      "version": "0.1.0",
 *      "start": "select_animals",
 *      "ops": {
 *          "select_animals": {
 *              "type": "split",
 *              "sequential": [
 *                  "home",
 *                  "home",
 *                  "home"
 *              ],
 *              "keyed": {
 *                  "cat": "home",
 *                  "dog": "home"
 *              },
 *              "remaining": "zoo"
 *          }
 *      }
 *  }
 *  # "#)?;
 *  # Ok::<_, serde_json::Error>(())
 *  ```
 *
 *  If we input `["frog", "cat", "bear", "beaver", "dog", "rabbit", "dog", "monkey"]`
 *  then `frog`, `bear`, and `beaver` will be sent to `home` since those are
 *  the first three animals that are not `dog` or `cat`, and we will also
 *  send one `cat` and two `dog` home. `rabbit` and `monkey` will be sent to the zoo.
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SplitSchema".
 */
export interface SplitSchema {
  /**
   * Override for text that should be displayed for an operation within an
   *  editor.
   */
  display_text?: string | null;
  keyed?: {
    [k: string]: NextOperation;
  };
  remaining?: NextOperation | null;
  sequential?: NextOperation[];
  trace?: TraceToggle | null;
  [k: string]: unknown;
}
/**
 * Wait for exactly one item to be available in each buffer listed in
 *  `buffers`, then join each of those items into a single output message
 *  that gets sent to `next`.
 *
 *  If the `next` operation is not a `node` type (e.g. `fork_clone`) then
 *  you must specify a `target_node` so that the diagram knows what data
 *  structure to join the values into.
 *
 *  The output message type must be registered as joinable at compile time.
 *  If you want to join into a dynamic data structure then you should use
 *  [`DiagramOperation::SerializedJoin`] instead.
 *
 *  # Examples
 *  ```
 *  # bevy_impulse::Diagram::from_json_str(r#"
 *  {
 *      "version": "0.1.0",
 *      "start": "begin_measuring",
 *      "ops": {
 *          "begin_measuring": {
 *              "type": "fork_clone",
 *              "next": ["localize", "imu"]
 *          },
 *          "localize": {
 *              "type": "node",
 *              "builder": "localize",
 *              "next": "estimated_position"
 *          },
 *          "imu": {
 *              "type": "node",
 *              "builder": "imu",
 *              "config": "velocity",
 *              "next": "estimated_velocity"
 *          },
 *          "estimated_position": { "type": "buffer" },
 *          "estimated_velocity": { "type": "buffer" },
 *          "gather_state": {
 *              "type": "join",
 *              "buffers": {
 *                  "position": "estimate_position",
 *                  "velocity": "estimate_velocity"
 *              },
 *              "next": "report_state"
 *          },
 *          "report_state": {
 *              "type": "node",
 *              "builder": "publish_state",
 *              "next": { "builtin": "terminate" }
 *          }
 *      }
 *  }
 *  # "#)?;
 *  # Ok::<_, serde_json::Error>(())
 *  ```
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "JoinSchema".
 */
export interface JoinSchema {
  buffers: BufferSelection;
  next: NextOperation;
  [k: string]: unknown;
}
/**
 * Same as [`DiagramOperation::Join`] but all input messages must be
 *  serializable, and the output message will always be [`serde_json::Value`].
 *
 *  If you use an array for `buffers` then the output message will be a
 *  [`serde_json::Value::Array`]. If you use a map for `buffers` then the
 *  output message will be a [`serde_json::Value::Object`].
 *
 *  Unlike [`DiagramOperation::Join`], the `target_node` property does not
 *  exist for this schema.
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SerializedJoinSchema".
 */
export interface SerializedJoinSchema {
  buffers: BufferSelection;
  next: NextOperation;
  [k: string]: unknown;
}
/**
 * If the request is serializable, transform it by running it through a [CEL](https://cel.dev/) program.
 *  The context includes a "request" variable which contains the input message.
 *
 *  # Examples
 *  ```
 *  # bevy_impulse::Diagram::from_json_str(r#"
 *  {
 *      "version": "0.1.0",
 *      "start": "transform",
 *      "ops": {
 *          "transform": {
 *              "type": "transform",
 *              "cel": "request.name",
 *              "next": { "builtin": "terminate" }
 *          }
 *      }
 *  }
 *  # "#)?;
 *  # Ok::<_, serde_json::Error>(())
 *  ```
 *
 *  Note that due to how `serde_json` performs serialization, positive integers are always
 *  serialized as unsigned. In CEL, You can't do an operation between unsigned and signed so
 *  it is recommended to always perform explicit casts.
 *
 *  # Examples
 *  ```
 *  # bevy_impulse::Diagram::from_json_str(r#"
 *  {
 *      "version": "0.1.0",
 *      "start": "transform",
 *      "ops": {
 *          "transform": {
 *              "type": "transform",
 *              "cel": "int(request.score) * 3",
 *              "next": { "builtin": "terminate" }
 *          }
 *      }
 *  }
 *  # "#)?;
 *  # Ok::<_, serde_json::Error>(())
 *  ```
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "TransformSchema".
 */
export interface TransformSchema {
  cel: string;
  /**
   * Override for text that should be displayed for an operation within an
   *  editor.
   */
  display_text?: string | null;
  next: NextOperation;
  on_error?: NextOperation | null;
  trace?: TraceToggle | null;
  [k: string]: unknown;
}
/**
 * Listen on a buffer.
 *
 *  # Examples
 *  ```
 *  # bevy_impulse::Diagram::from_json_str(r#"
 *  {
 *      "version": "0.1.0",
 *      "start": "num_output",
 *      "ops": {
 *          "buffer": {
 *              "type": "buffer"
 *          },
 *          "num_output": {
 *              "type": "node",
 *              "builder": "num_output",
 *              "next": "buffer"
 *          },
 *          "listen": {
 *              "type": "listen",
 *              "buffers": ["buffer"],
 *              "target_node": "listen_buffer",
 *              "next": "listen_buffer"
 *          },
 *          "listen_buffer": {
 *              "type": "node",
 *              "builder": "listen_buffer",
 *              "next": { "builtin": "terminate" }
 *          }
 *      }
 *  }
 *  # "#)?;
 *  # Ok::<_, serde_json::Error>(())
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "ListenSchema".
 */
export interface ListenSchema {
  buffers: BufferSelection;
  next: NextOperation;
  target_node?: NextOperation | null;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SectionTemplate".
 */
export interface SectionTemplate {
  buffers?: InputRemapping;
  inputs?: InputRemapping;
  /**
   * Operations that define the behavior of the section.
   */
  ops: {
    [k: string]: DiagramOperation;
  };
  /**
   * These are the outputs that the section is exposing so you can connect
   *  them into siblings of the section.
   */
  outputs?: string[];
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "DiagramElementRegistry".
 */
export interface DiagramElementRegistry {
  messages: {
    [k: string]: MessageRegistration;
  };
  nodes: {
    [k: string]: NodeRegistration;
  };
  schemas: {
    [k: string]: unknown;
  };
  sections: {
    [k: string]: SectionRegistration;
  };
  trace_supported: boolean;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "MessageRegistration".
 */
export interface MessageRegistration {
  operations: MessageOperation;
  schema?: Schema | null;
  type_name: string;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "MessageOperation".
 */
export interface MessageOperation {
  deserialize?: {
    [k: string]: unknown;
  } | null;
  fork_clone?: {
    [k: string]: unknown;
  } | null;
  fork_result?: {
    [k: string]: unknown;
  } | null;
  join?: {
    [k: string]: unknown;
  } | null;
  serialize?: {
    [k: string]: unknown;
  } | null;
  split?: {
    [k: string]: unknown;
  } | null;
  unzip?: string[] | null;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "NodeRegistration".
 */
export interface NodeRegistration {
  config_schema: Schema;
  /**
   * If the user does not specify a default display text, the node ID will
   *  be used here.
   */
  default_display_text: string;
  request: string;
  response: string;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SectionRegistration".
 */
export interface SectionRegistration {
  config_schema: Schema;
  default_display_text: string;
  metadata: SectionMetadata;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SectionMetadata".
 */
export interface SectionMetadata {
  buffers: {
    [k: string]: SectionBuffer;
  };
  inputs: {
    [k: string]: SectionInput;
  };
  outputs: {
    [k: string]: SectionOutput;
  };
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SectionBuffer".
 */
export interface SectionBuffer {
  item_type?: string | null;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SectionInput".
 */
export interface SectionInput {
  message_type: string;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SectionOutput".
 */
export interface SectionOutput {
  message_type: string;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "PostRunRequest".
 */
export interface PostRunRequest {
  diagram: Diagram;
  request: unknown;
  [k: string]: unknown;
}
