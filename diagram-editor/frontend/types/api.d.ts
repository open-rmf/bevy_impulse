/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "BufferSelection".
 */
export type BufferSelection =
  | {
      [k: string]: NextOperation;
    }
  | NextOperation[];
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "NextOperation".
 */
export type NextOperation =
  | string
  | {
      builtin: BuiltinTarget;
      [k: string]: unknown;
    }
  | NamespacedOperation;
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "BuiltinTarget".
 */
export type BuiltinTarget = 'terminate' | 'dispose' | 'cancel';
/**
 * Describe how data within a buffer gets retained. Most mechanisms that pull
 *  data from a buffer will remove the oldest item in the buffer, so this policy
 *  is for dealing with situations where items are being stored faster than they
 *  are being pulled.
 *
 *  The default value is KeepLast(1).
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "RetentionPolicy".
 */
export type RetentionPolicy =
  | {
      keep_last: number;
    }
  | {
      keep_first: number;
    }
  | 'keep_all';
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "DebugSessionEnd".
 */
export type DebugSessionEnd =
  | {
      Ok: unknown;
    }
  | {
      Err: string;
    };
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "DiagramOperation".
 */
export type DiagramOperation =
  | ({
      type: 'node';
      [k: string]: unknown;
    } & NodeSchema)
  | ({
      type: 'section';
      [k: string]: unknown;
    } & SectionSchema)
  | ({
      type: 'scope';
      [k: string]: unknown;
    } & ScopeSchema)
  | ({
      type: 'stream_out';
      [k: string]: unknown;
    } & StreamOutSchema)
  | ({
      type: 'fork_clone';
      [k: string]: unknown;
    } & ForkCloneSchema)
  | ({
      type: 'unzip';
      [k: string]: unknown;
    } & UnzipSchema)
  | ({
      type: 'fork_result';
      [k: string]: unknown;
    } & ForkResultSchema)
  | ({
      type: 'split';
      [k: string]: unknown;
    } & SplitSchema)
  | ({
      type: 'join';
      [k: string]: unknown;
    } & JoinSchema)
  | ({
      type: 'serialized_join';
      [k: string]: unknown;
    } & SerializedJoinSchema)
  | ({
      type: 'transform';
      [k: string]: unknown;
    } & TransformSchema)
  | ({
      type: 'buffer';
      [k: string]: unknown;
    } & BufferSchema)
  | ({
      type: 'buffer_access';
      [k: string]: unknown;
    } & BufferAccessSchema)
  | ({
      type: 'listen';
      [k: string]: unknown;
    } & ListenSchema);
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SectionSchema".
 */
export type SectionSchema = {
  config?: {
    [k: string]: unknown;
  };
  connect?: {
    [k: string]: NextOperation;
  };
  [k: string]: unknown;
} & SectionSchema1;
export type SectionSchema1 =
  | {
      builder: string;
      [k: string]: unknown;
    }
  | {
      template: string;
      [k: string]: unknown;
    };
/**
 * This defines how sections remap their inner operations (inputs and buffers)
 *  to expose them to operations that are siblings to the section.
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "InputRemapping".
 */
export type InputRemapping =
  | string[]
  | {
      [k: string]: NextOperation;
    };
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "Schema".
 */
export type Schema =
  | {
      [k: string]: unknown;
    }
  | boolean;

export interface DiagramEditorApi {
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "BufferAccessSchema".
 */
export interface BufferAccessSchema {
  buffers: BufferSelection;
  next: NextOperation;
  [k: string]: unknown;
}
/**
 * Refer to an operation inside of a namespace, e.g. { "<namespace>": "<operation>"
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "NamespacedOperation".
 */
export interface NamespacedOperation {
  [k: string]: string;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "BufferSchema".
 */
export interface BufferSchema {
  /**
   * If true, messages will be serialized before sending into the buffer.
   */
  serialize?: boolean | null;
  settings?: {
    [k: string]: unknown;
  } & BufferSettings;
  [k: string]: unknown;
}
/**
 * Settings to describe the behavior of a buffer.
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "BufferSettings".
 */
export interface BufferSettings {
  retention: RetentionPolicy;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "Diagram".
 */
export interface Diagram {
  /**
   * To simplify diagram definitions, the diagram workflow builder will
   *  sometimes insert implicit operations into the workflow, such as implicit
   *  serializing and deserializing. These implicit operations may be fallible.
   *
   *  This field indicates how a failed implicit operation should be handled.
   *  If left unspecified, an implicit error will cause the entire workflow to
   *  be cancelled.
   */
  on_implicit_error?: NextOperation | null;
  /**
   * Operations that define the workflow
   */
  ops: {
    [k: string]: DiagramOperation;
  };
  start: NextOperation;
  templates?: {
    [k: string]: SectionTemplate;
  };
  /**
   * Version of the diagram, should always be `0.1.0`.
   */
  version: string;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "NodeSchema".
 */
export interface NodeSchema {
  builder: string;
  config?: unknown;
  next: NextOperation;
  stream_out?: {
    [k: string]: NextOperation;
  };
  [k: string]: unknown;
}
/**
 * The schema to define a scope within a diagram.
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "ScopeSchema".
 */
export interface ScopeSchema {
  next: NextOperation;
  /**
   * To simplify diagram definitions, the diagram workflow builder will
   *  sometimes insert implicit operations into the workflow, such as implicit
   *  serializing and deserializing. These implicit operations may be fallible.
   *
   *  This field indicates how a failed implicit operation should be handled.
   *  If left unspecified, an implicit error will cause the entire workflow to
   *  be cancelled.
   */
  on_implicit_error?: NextOperation | null;
  /**
   * Operations that exist inside this scope.
   */
  ops: {
    [k: string]: DiagramOperation;
  };
  settings?: {
    [k: string]: unknown;
  } & ScopeSettings;
  start: NextOperation;
  /**
   * Where to connect streams that are coming out of this scope.
   */
  stream_out?: {
    [k: string]: NextOperation;
  };
  [k: string]: unknown;
}
/**
 * Settings which determine how the top-level scope of the workflow behaves.
 *
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "ScopeSettings".
 */
export interface ScopeSettings {
  /**
   * Should we prevent the scope from being interrupted (e.g. cancelled)?
   *  False by default, meaning by default scopes can be cancelled or
   *  interrupted.
   */
  uninterruptible: boolean;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "StreamOutSchema".
 */
export interface StreamOutSchema {
  /**
   * The name of the stream exiting the workflow or scope.
   */
  name: string;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "ForkCloneSchema".
 */
export interface ForkCloneSchema {
  next: NextOperation[];
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "UnzipSchema".
 */
export interface UnzipSchema {
  next: NextOperation[];
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "ForkResultSchema".
 */
export interface ForkResultSchema {
  err: NextOperation;
  ok: NextOperation;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SplitSchema".
 */
export interface SplitSchema {
  keyed?: {
    [k: string]: NextOperation;
  };
  remaining?: NextOperation | null;
  sequential?: NextOperation[];
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "JoinSchema".
 */
export interface JoinSchema {
  buffers: BufferSelection;
  next: NextOperation;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SerializedJoinSchema".
 */
export interface SerializedJoinSchema {
  buffers: BufferSelection;
  next: NextOperation;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "TransformSchema".
 */
export interface TransformSchema {
  cel: string;
  next: NextOperation;
  /**
   * Specify what happens if an error occurs during the transformation. If
   *  you specify a target for on_error, then an error message will be sent to
   *  that target. You can set this to `{ "builtin": "dispose" }` to simply
   *  ignore errors.
   *
   *  If left unspecified, a failure will be treated like an implicit operation
   *  failure and behave according to `on_implicit_error`.
   */
  on_error?: NextOperation | null;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "ListenSchema".
 */
export interface ListenSchema {
  buffers: BufferSelection;
  next: NextOperation;
  /**
   * The id of an operation that this operation is for. The id must be a `node` operation. Optional if `next` is a node operation.
   */
  target_node?: NextOperation | null;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SectionTemplate".
 */
export interface SectionTemplate {
  buffers?: {
    [k: string]: unknown;
  } & InputRemapping;
  inputs?: {
    [k: string]: unknown;
  } & InputRemapping;
  /**
   * Operations that define the behavior of the section.
   */
  ops: {
    [k: string]: DiagramOperation;
  };
  /**
   * These are the outputs that the section is exposing so you can connect
   *  them into siblings of the section.
   */
  outputs?: string[];
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "DiagramElementRegistry".
 */
export interface DiagramElementRegistry {
  messages: {
    [k: string]: MessageRegistration;
  };
  nodes: {
    [k: string]: NodeRegistration;
  };
  schemas: {
    [k: string]: unknown;
  };
  sections: {
    [k: string]: SectionRegistration;
  };
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "MessageRegistration".
 */
export interface MessageRegistration {
  operations: MessageOperation;
  schema?: Schema | null;
  type_name: string;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "MessageOperation".
 */
export interface MessageOperation {
  deserialize?: {
    [k: string]: unknown;
  } | null;
  fork_clone?: {
    [k: string]: unknown;
  } | null;
  fork_result?: {
    [k: string]: unknown;
  } | null;
  join?: {
    [k: string]: unknown;
  } | null;
  serialize?: {
    [k: string]: unknown;
  } | null;
  split?: {
    [k: string]: unknown;
  } | null;
  unzip?: string[] | null;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "NodeRegistration".
 */
export interface NodeRegistration {
  config_schema: Schema;
  name: string;
  request: string;
  response: string;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SectionRegistration".
 */
export interface SectionRegistration {
  config_schema: Schema;
  metadata: SectionMetadata;
  name: string;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SectionMetadata".
 */
export interface SectionMetadata {
  buffers: {
    [k: string]: SectionBuffer;
  };
  inputs: {
    [k: string]: SectionInput;
  };
  outputs: {
    [k: string]: SectionOutput;
  };
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SectionBuffer".
 */
export interface SectionBuffer {
  item_type?: string | null;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SectionInput".
 */
export interface SectionInput {
  message_type: string;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "SectionOutput".
 */
export interface SectionOutput {
  message_type: string;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `DiagramEditorApi`'s JSON-Schema
 * via the `definition` "PostRunRequest".
 */
export interface PostRunRequest {
  diagram: Diagram;
  request: unknown;
  [k: string]: unknown;
}
